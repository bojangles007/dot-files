#+OPTIONS: fn:t h:4
#+PROPERTY: header-args:sh         :tangle yes
#+PROPERTY: header-args            :results silent
* My Emacs Config
  This is my Emacs configuration. Because I'm prone to forget what does what,
  my configuration is in the form of a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose,
  interspaced with code.

  After many years with BBEdit I started looking at Emacs again when I started
  learning Clojure. I started with the "better defaults" package and added
  things one-by-one as I found them, rather than stealing someone else's
  mammoth =.emacs= file that I didn't understand any of. Initially I drew a
  lot of inspiration from [[https://github.com/magnars/.emacs.d][magnars' .emacs.d]], but after rewriting it using
  [[https://github.com/jwiegley/use-package][use-package]] (which is excellent) it is starting to feel like my own work.

** Tangled shell script snippets

   This document doesn't just contain =emacs-lisp= snippets. It also contains
   some shell snippets to install Emacs itself, and some helper programs. By
   invoking =C-c C-v t= on this document a =README.sh= file is produced, that
   contains shell commands that will install all the helper programs via /brew/.

** Install Emacs & This Configuration

   Create a symlink from =$HOME/.emacs.d= to the directory containing this
   file. If =$HOME/.emacs.d= is already a symbolic link, delete it first. If
   it is a directory, move it out of the way.

   #+BEGIN_SRC sh
     test -L ~/.emacs.d && rm ~/.emacs.d
     test -d ~/.emacs.d && mv ~/.emacs.d ~/.emacs.d.$(date +%s)
     ln -s ~/Dotfiles/emacs.d ~/.emacs.d
   #+END_SRC

   Then use [[http://brew.sh][brew]] to install Emacs:

   #+BEGIN_SRC sh
     brew install emacs --with-cocoa
   #+END_SRC

*** Leiningen

    This is used by Cider. Installed with brew, of course:

    #+BEGIN_SRC sh
      brew install leiningen
    #+END_SRC

*** Fix "weird characters" in =ansi-term= mode

    For some reason Emacs' =ansi-term= mode displays some "weird characters".
    To fix this, copy [[https://gist.github.com/stig/0c8bc5aeb8602cdb45de#file-ansi-term-ti][ansi-term.ti]] to somewhere locally and run =tic= on it to
    create =.terminfo=:

    #+BEGIN_SRC sh
    curl 'https://gist.githubusercontent.com/stig/0c8bc5aeb8602cdb45de/raw/e20e6fb0a0d937b51dfdd4107053ac0b140efb2c/ansi-term.ti' > /tmp/ansi-term.ti
    tic -o ~/.terminfo /tmp/ansi-term.ti
    #+END_SRC

*** Trash

    This allows moving files to trash rather than deleting them from =dired=.
    I find that handy.

    #+BEGIN_SRC sh
    brew install trash
    #+END_SRC

** Configuration

   Alright! Now on to the actual configuration.

*** Disable mouse interface, splash screen & beeps

    I don't tend to use a mouse in Emacs very often, so I turn off mouse
    interface early to avoid momentary display during launch.

    #+BEGIN_SRC emacs-lisp
      (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
      (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    #+END_SRC

    I also don't need to see a splash screen on every launch.

    #+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-message t)
    #+END_SRC

    I do not like Emacs to beep at me; I prefer a visual bell. Unfortunately
    in the current stable release there is a bug that causes [[http://debbugs.gnu.org/cgi/bugreport.cgi?bug%3D21662][visual artefacts]]
    on El Capitan. The workaround is to turn off visual bell, but make the
    function that actually rings the bell be a no-op. I'd like to get the
    visual bell back one day. It's been fixed upstream, but I've not been
    brave enough to build =--HEAD= yet, so so far I've stuck with the stable
    builds.

    #+BEGIN_SRC emacs-lisp
      (setq visible-bell nil)
      (setq ring-bell-function 'ignore)
    #+END_SRC

*** Put Custom settings in a separate file

    I prefer to code my configuration, but sometimes Custom settings are good
    enough. I prefer that such settings live in a separate file though. Load
    that file if it exists.

    #+BEGIN_SRC emacs-lisp
      (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
      (if (file-exists-p custom-file)
          (load custom-file))
    #+END_SRC

*** Internationalisation

    Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

    #+BEGIN_SRC emacs-lisp
      (setq locale-coding-system 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
    #+END_SRC

    Let's define keybindings for the three additional Norwegian characters
    characters that I don't have natively on my British keyboard.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-'") (kbd "æ"))
      (global-set-key (kbd "s-\"") (kbd "Æ"))
      (global-set-key (kbd "s-O") (kbd "Ø"))
      (global-set-key (kbd "s-o") (kbd "ø"))
      (global-set-key (kbd "s-A") (kbd "Å"))
      (global-set-key (kbd "s-a") (kbd "å"))
    #+END_SRC

*** Use Aspell with UK English Dictionary

    Configure Emacs to use the Queen's English for spell checking. Also, use
    /aspell/ rather than /ispell/.

    #+BEGIN_SRC emacs-lisp
      (setq ispell-program-name "aspell"
            ispell-dictionary "british")
    #+END_SRC

    Install aspell with the appropriate dictionary using brew.

    #+BEGIN_SRC sh
      brew install aspell --with-lang-uk
    #+END_SRC

*** Whitespace

    I prefer slightly wider fill-rate than the default of 70. Let's make it
    78, so we stay within 80 characters that so many people consider the holy
    grail. Also, let's wrap automatically at that width in =text-mode=.
    Finally disable =s-q= (=kill-emacs=) as it is too close to M-q which I use
    for reflowing text.

    #+BEGIN_SRC emacs-lisp
      (setq-default fill-column 78)
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      (global-set-key (kbd "s-q") nil)
    #+END_SRC

    Sentences do not need double spaces to end. Period.

    #+BEGIN_SRC emacs-lisp
      (set-default 'sentence-end-double-space nil)
    #+END_SRC

    Never insert tabs.

  #+BEGIN_SRC emacs-lisp
    (set-default 'indent-tabs-mode nil)
  #+END_SRC

    All files should end in a newline. Insert one if there isn't one already.

    #+BEGIN_SRC emacs-lisp
      (setq require-final-newline t)
    #+END_SRC

    This highlights certain whitespace annoyances, and adds a key binding to
    clean it up.

    #+BEGIN_SRC emacs-lisp
      (require 'whitespace)
      (setq whitespace-style '(face empty tabs trailing))
      (global-whitespace-mode t)

      (global-set-key (kbd "s-w") 'whitespace-cleanup)
    #+END_SRC

*** OS X Specific

    Set up the modifier keys the way that best fits my keyboard.

    #+BEGIN_SRC emacs-lisp
      (setq mac-command-modifier 'meta
            mac-option-modifier 'super
            mac-control-modifier 'control
            ns-function-modifier 'hyper)
    #+END_SRC

    Delete files by moving them to Trash. This way they _can_ be retrieved
    again.

    #+BEGIN_SRC emacs-lisp
      (setq delete-by-moving-to-trash t)
    #+END_SRC

*** Miscellaneous

    When files change on disk, revert the buffer automatically.

    #+BEGIN_SRC emacs-lisp
      (global-auto-revert-mode 1)
    #+END_SRC

    I don't like backup files all over my disk. This places them in
    =~/.emacs.d/backups=.

    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
    #+END_SRC

    I *do* like it when Emacs transparently opens compressed files. It gives
    me the warm fuzzies.

    #+BEGIN_SRC emacs-lisp
      (auto-compression-mode t)
    #+END_SRC

    Answering just 'y' or 'n' will do, rather than having to spell out "yes"
    or "no".

    #+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

*** Useful Functions

**** Comment or uncomment line or region

     I found this on StackOverflow, I think. If no region is selected it will
     toggle the current programming mode's comment for that line. If a region
     is selected it will comment/uncomment the region.

     #+BEGIN_SRC emacs-lisp
       (defun comment-or-uncomment-region-or-line ()
         "Comments or uncomments the region or the current line if there's no active region."
         (interactive)
         (let (beg end)
           (if (region-active-p)
               (setq beg (region-beginning) end (region-end))
             (setq beg (line-beginning-position) end (line-end-position)))
           (comment-or-uncomment-region beg end)
           (next-line)))

       (global-set-key (kbd "s-c") 'comment-or-uncomment-region-or-line)
     #+END_SRC

**** Replace smart quotes

     At some point I needed to remove some "smart quotes" from a blog post
     draft created in OS X Notes. I came up with this function. I don't
     remember needing to use it again, but I keep it for sentimental reasons.
     (It doesn't even have a keybinding!)

     #+BEGIN_SRC emacs-lisp
       (defun replace-smart-quotes (beg end)
         "Replace 'smart quotes' in buffer or region with ascii quotes."
         (interactive "r")
         (format-replace-strings '(("\x201C" . "\"")
                                   ("\x201D" . "\"")
                                   ("\x2018" . "'")
                                   ("\x2019" . "'"))
                                 nil beg end))
     #+END_SRC

**** Toggle Window Split

     Sometimes a window is split horizontally, and you would prefer
     vertically. Or vice versa. This function can help! Just don't ask me how
     it works: I found it on StackOverflow. (I think. Again.)

     #+BEGIN_SRC emacs-lisp
       (defun toggle-window-split ()
         (interactive)
         (if (= (count-windows) 2)
             (let* ((this-win-buffer (window-buffer))
                    (next-win-buffer (window-buffer (next-window)))
                    (this-win-edges (window-edges (selected-window)))
                    (next-win-edges (window-edges (next-window)))
                    (this-win-2nd (not (and (<= (car this-win-edges)
                                                (car next-win-edges))
                                            (<= (cadr this-win-edges)
                                                (cadr next-win-edges)))))
                    (splitter
                     (if (= (car this-win-edges)
                            (car (window-edges (next-window))))
                         'split-window-horizontally
                       'split-window-vertically)))
               (delete-other-windows)
               (let ((first-win (selected-window)))
                 (funcall splitter)
                 (if this-win-2nd (other-window 1))
                 (set-window-buffer (selected-window) this-win-buffer)
                 (set-window-buffer (next-window) next-win-buffer)
                 (select-window first-win)
                 (if this-win-2nd (other-window 1))))))

       (define-key ctl-x-4-map "t" 'toggle-window-split)
     #+END_SRC

**** Delete the file for the current buffer

     "Delete this file." Simple, huh?

     #+BEGIN_SRC emacs-lisp
       (defun delete-current-buffer-file ()
         "Removes file connected to current buffer and kills buffer."
         (interactive)
         (let ((filename (buffer-file-name))
               (buffer (current-buffer))
               (name (buffer-name)))
           (if (not (and filename (file-exists-p filename)))
               (ido-kill-buffer)
             (when (yes-or-no-p "Are you sure you want to remove this file? ")
               (delete-file filename)
               (kill-buffer buffer)
               (message "File '%s' successfully removed" filename)))))

       (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
     #+END_SRC

*** Mode-specific stuff

**** Tramp

     Allow using sudo over ssh, so we can sudo to root remotely on a machine
     that does not allow root login.

     #+BEGIN_SRC emacs-lisp
       (set-default 'tramp-default-proxies-alist
                    (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
     #+END_SRC

     For opening files using sudo locally, don't connect via SSH. (My local
     machine doesn't accept SSH connections.)

     #+BEGIN_SRC emacs-lisp
       (add-to-list 'tramp-default-proxies-alist
               '((regexp-quote (system-name)) nil nil))
     #+END_SRC

     If I don't set this then tramp will attempt to use OS X's tempfile
     directory on a remote machine, which does not work. I don't understand
     why it won't use the remote machine's temp directory automatically, but
     there you go.

     #+BEGIN_SRC emacs-lisp
       (setq temporary-file-directory "/tmp/")
     #+END_SRC

     This function lets me re-open the currently open file using sudo[fn:1].
     I've bound it to =C-c C-s=. It works for both local and remote buffers.

     #+BEGIN_SRC emacs-lisp
       (defun sudo-edit-current-file ()
         (interactive)
         (let ((position (point)))
           (find-alternate-file
            (if (file-remote-p (buffer-file-name))
                (let ((vec (tramp-dissect-file-name (buffer-file-name))))
                  (tramp-make-tramp-file-name
                   "sudo"
                   (tramp-file-name-user vec)
                   (tramp-file-name-host vec)
                   (tramp-file-name-localname vec)))
              (concat "/sudo::" (buffer-file-name))))
           (goto-char position)))

       (global-set-key (kbd "C-c C-s") 'sudo-edit-current-file)
     #+END_SRC

* TODO Split & document this lot

    Some of this I have _no_ idea what it does. I guess I just take it out and
    see what breaks?

  #+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)

  ;; Show active region
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)

  ;; Save a list of recent files visited. (open recent file with C-x f)
  (recentf-mode 1)
  (setq recentf-max-saved-items 100) ;; just 20 is too recent

  ;; Save minibuffer history
  (savehist-mode 1)
  (setq history-length 1000)

  (setq-default save-place t)
  (setq save-place-file (concat user-emacs-directory "places"))

  (show-paren-mode 1)

  ;; Improve pasting behaviour with programs outside Emacs
  (setq x-select-enable-clipboard t
        x-select-enable-primary t
        save-interprogram-paste-before-kill t
        mouse-yank-at-point t)

  ;; Auto refresh dired, but be quiet about it
  (setq global-auto-revert-non-file-buffers t
        auto-revert-verbose nil)

  ;; Launch/switch to eshell more easily
  (global-set-key (kbd "C-c s") 'eshell)



  ;; Join line below
  (global-set-key (kbd "M-j")
                  (lambda ()
                    (interactive)
                    (join-line -1)))



  (require 'server)
  (unless (server-running-p)
    (server-start))

  #+END_SRC

* Package Installation & Configuration

  I install quite a few packages from [[http://melpa.org/][melpa]]. First add the URLs of the
  archives we want to use, then initiate already installed packages.

** Initialisation

   #+BEGIN_SRC emacs-lisp
     (setq package-archives
           '(("gnu" . "http://elpa.gnu.org/packages/")
             ("melpa" . "http://melpa.milkbox.net/packages/")
             ("melpa-stable" . "http://stable.milkbox.net/packages/")))
     (package-initialize)
   #+END_SRC

** use-package

   I use the excellent [[https://github.com/jwiegley/use-package][use-package]] for installing & configuring packages.
   There's a minor bootstrapping problem: we have to make sure /it/ is
   installed.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (message "%s" "Refreshing package database...")
       (package-refresh-contents)
       (package-install 'use-package))
   #+END_SRC

   Configure =use-package= pre-compile the configuration for faster loading.

   #+BEGIN_SRC emacs-lisp
     (eval-when-compile
       (require 'use-package))
     (require 'bind-key)
   #+END_SRC

** Leuven Theme

   Install & activate a nice-looking theme.

   #+BEGIN_SRC emacs-lisp
     (use-package leuven-theme
       :ensure t
       :config
       (load-theme 'leuven t))
   #+END_SRC

** Magit

   I use [[http://magit.vc][Magit]] all day. If you use git a lot it's possibly worth switching to
   Emacs just for it. It is excellent. I bind =M-m= to =magit-status=, which
   is the main entry point for the mode.

   I also use a Magit plugin that interacts with GitHub, allowing me to create
   pull-requests from within Emacs.

   #+BEGIN_SRC emacs-lisp
      (use-package magit
     :ensure t

     :bind ("M-m" . magit-status)

     :init
     (setq magit-git-executable "/usr/bin/git"
           git-commit-summary-max-length 65
           magit-diff-refine-hunk 'all
           magit-push-always-verify nil)

     :config
     (use-package magit-gh-pulls
       :ensure t
       :config
       (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls)))
   #+END_SRC

** SmartParens

   I use smartparens rather that paredit. I cannot remember why; probably
   something to do with it being better supported for Cider/Clojure? Anyway,
   here's my SmartParen config. It is  mostly cribbed from the author, with
   small changes to make suitable for plugging into =user-package=.

   One notable thing: I remove "'" from being a pair, because that character
   is used for quoting in lisps, and for apostrophe in text modes. Having two
   inserted every time you hit the key is very annoying.

   #+BEGIN_SRC emacs-lisp
   (use-package smartparens
     :ensure t

     :config
     (smartparens-global-mode t)
     (show-smartparens-global-mode t)
     (sp-pair "'" nil :actions :rem)

     ;; Add smartparens-strict-mode to all sp--lisp-modes hooks. C-h v sp--lisp-modes
     ;; to customize/view this list.
     (mapc (lambda (mode)
             (add-hook (intern (format "%s-hook" (symbol-name mode))) 'smartparens-strict-mode))
           sp--lisp-modes)

     ;; Conveniently set keys into the sp-keymap, limiting the keybinding to buffers
     ;; with SP mode activated
     (mapc (lambda (info)
             (let ((key (kbd (car info)))
                   (function (car (cdr info))))
               (define-key sp-keymap key function)))
           '(("C-M-f" sp-forward-sexp)
             ("C-M-b" sp-backward-sexp)

             ("C-M-d" sp-down-sexp)
             ("C-M-a" sp-backward-down-sexp)
             ("C-S-a" sp-beginning-of-sexp)
             ("C-S-d" sp-end-of-sexp)

             ("C-M-e" sp-up-sexp)

             ("C-M-u" sp-backward-up-sexp)
             ("C-M-t" sp-transpose-sexp)

             ("C-M-n" sp-next-sexp)
             ("C-M-p" sp-previous-sexp)

             ("C-M-k" sp-kill-sexp)
             ("C-M-w" sp-copy-sexp)

             ("C-M-<delete>" sp-unwrap-sexp)
             ("C-M-<backspace>" sp-backward-unwrap-sexp)

             ("C-<right>" sp-forward-slurp-sexp)
             ("C-<left>" sp-forward-barf-sexp)
             ("C-M-<left>" sp-backward-slurp-sexp)
             ("C-M-<right>" sp-backward-barf-sexp)

             ("M-D" sp-splice-sexp)
             ("C-M-<delete>" sp-splice-sexp-killing-forward)
             ("C-M-<backspace>" sp-splice-sexp-killing-backward)
             ("C-S-<backspace>" sp-splice-sexp-killing-around)

             ("C-]" sp-select-next-thing-exchange)
             ("C-<left_bracket>" sp-select-previous-thing)
             ("C-M-]" sp-select-next-thing)

             ("M-F" sp-forward-symbol)
             ("M-B" sp-backward-symbol)

             ("H-t" sp-prefix-tag-object)
             ("H-p" sp-prefix-pair-object)
             ("H-s c" sp-convolute-sexp)
             ("H-s a" sp-absorb-sexp)
             ("H-s e" sp-emit-sexp)
             ("H-s p" sp-add-to-previous-sexp)
             ("H-s n" sp-add-to-next-sexp)
             ("H-s j" sp-join-sexp)
             ("H-s s" sp-split-sexp)))

     ;; In Lisp modes, let ')' go to end of sexp
     (bind-key ")" 'sp-up-sexp emacs-lisp-mode-map)
     (bind-key ")" 'sp-up-sexp lisp-mode-map))
   #+END_SRC

** Aggressive Indent

   I like to keep my code indented properly at all times. Aggressive-indent
   helps ensure this. Turn it on for lisp modes.

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :ensure t

       :config
       (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
       ;;     (add-hook 'puppet-mode-hook #'aggressive-indent-mode)
       (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
       (add-hook 'css-mode-hook #'aggressive-indent-mode))
   #+END_SRC

** Helm

   I use [[https://github.com/emacs-helm/helm][Helm]] for interactive completion and finding things, particularly files.

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t

       :bind (("C-c C-h e" . helm-list-elisp-packages)
              ("C-c C-h r" . helm-resume)
              ("M-x" . helm-M-x)
              ("M-y" . helm-show-kill-ring)
              ("C-x b" . helm-mini)
              ("C-x 4 b" . helm-mini)
              ("C-x C-f" . helm-find-files)))
   #+END_SRC

** Autocomplete

   I use auto-complete. I am not entirely sure to what extent, but this is my
   config for it.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-complete
       :ensure t
       :config
       (ac-config-default))
   #+END_SRC

   When it would be embarrassing to mistype long words, there's always
   ispell-based auto-complete.

   #+BEGIN_SRC emacs-lisp
     (use-package ac-ispell
       :init
       ;; Completion words longer than 12 characters
       (custom-set-variables
        '(ac-ispell-requires 12)
        '(ac-ispell-fuzzy-limit 12))

       :config
       (ac-ispell-setup)

       (add-hook 'git-commit-mode-hook 'ac-ispell-ac-setup)
       (add-hook 'mail-mode-hook 'ac-ispell-ac-setup))
   #+END_SRC

   Autocomplete for reStructuredText is very useful.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-complete-rst
       :mode "\\.rst\'"
       :config
       (auto-complete-rst-init)
       (setq auto-complete-rst-other-sources
             '(ac-source-filename
               ac-source-abbrev
               ac-source-dictionary
               ac-source-yasnippet)))
   #+END_SRC

** Editorconfig

   Some projects I touch, particularly at work, use [[http://editorconfig.org][editorconfig]] to set up
   their indentation and file format preferences.

   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :ensure t)
   #+END_SRC

   Emacs requires an external tool for this to work. I install that using
   brew.

   #+BEGIN_SRC sh
     brew install editorconfig
   #+END_SRC

** Puppet

   My work includes editing a lot of puppet manifests. Puppet-mode makes that
   more convenient.

   #+BEGIN_SRC emacs-lisp
     (use-package puppet-mode
       :ensure t
       :mode "\\.pp'")
   #+END_SRC

** Ag / The Silver Searcher

   I use =ag= for searching quite a lot in Emacs.
   This requires an additional external tool for best performance:

   #+BEGIN_SRC sh
     brew install the_silver_searcher
   #+END_SRC

   Then make sure the Emacs ag package is installed.

   #+BEGIN_SRC emacs-lisp
     (use-package ag :ensure t)
   #+END_SRC

   The =helm-ag= package allows me to refine ag results (in case there are
   very many) using Helm's interactive narrowing down.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-ag :ensure t)
   #+END_SRC

   "Writable grep" mode for ag is pretty close to magic. When in a buffer
   showing ag results, try hitting =C-c C-p=--this lets you _edit the results
   of the search, right from the ag results buffer!_ Just hit =C-x C-s= to
   save the results.

   If you hit =C-c C-p= while already in writable grep mode you can delete the
   entire matched line from the file where it was found by hitting =C-c C-d=
   on it. I use this _a lot_ when cleaning up Hieradata.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep-ag :ensure t)
   #+END_SRC

** Projectile

   I use Projectile to navigate my projects. Some of the things I like about
   it are that it provides the following key bindings:

   - =C-c p t= :: This switches from an implementation file to its test file,
                  or vice versa. I use this extensively in Clojure mode. It
                  might not make sense for all languages; YMMV.
   - =C-c p 4 t= :: The same, as above, but open the file in "other" buffer.
   - =C-c p s s= :: Ag search for something in this project. If point is at a
                    token, default to searching for that. (Mnemonic:
                    "Projectile Silver Searcher".)

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (projectile-global-mode))
   #+END_SRC

   This next package adds =C-c p h=, which invokes =helm-find-file= in project
   context. Invaluable.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :ensure t)
   #+END_SRC


** TODO Rest

   #+BEGIN_SRC emacs-lisp




   (use-package multiple-cursors
     :ensure t

     :bind (("C-c a" . mc/edit-lines)
            ("C-c C-a" . mc/mark-all-dwim)
            ("s-n" . mc/mark-next-like-this)
            ("s-p" . mc/mark-previous-like-this)))

   (use-package yasnippet
     :init
     (add-hook 'clojure-mode-hook 'yas-minor-mode-on)
     (add-hook 'markdown-mode-hook 'yas-minor-mode-on)

     :config
     (defun yas/org-very-safe-expand ()
       (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

     (defun yas/org-setup ()
       ;; yasnippet (using the new org-cycle hooks)
       (make-variable-buffer-local 'yas/trigger-key)
       (setq yas/trigger-key [tab])
       (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
       (define-key yas/keymap [tab] 'yas/next-field))

     ;; See https://github.com/eschulte/emacs24-starter-kit/issues/80.
     (setq org-src-tab-acts-natively nil)

     (add-hook 'org-mode-hook #'yas/org-setup))

   (use-package clojure-mode
     :pin melpa-stable
     :mode "\\.clj\\'"
     :ensure t

     :config
     (bind-key ")" 'sp-up-sexp clojure-mode-map)

     (use-package clj-refactor
       :pin melpa-stable
       :ensure t
       :config
       (dolist (mapping '(("route" . "compojure.route")
                          ("timbre" . "taoensso.timbre")
                          ("component" . "com.stuartsierra.component")
                          ("d" . "datomic.api")
                          ("io" . "clojure.java.io")
                          ("tc" . "clojure.test.check")
                          ("gen" . "clojure.test.check.generators")
                          ("prop" . "clojure.test.check.properties")
                          ("prop'" . "com.gfredericks.test.chuck.properties")))
         (add-to-list 'cljr-magic-require-namespaces mapping t))

       :config
       (defun my-clojure-mode-hook ()
         (clj-refactor-mode 1)
         ;;(cljr-add-keybindings-with-prefix "C-c C-m")
         )

       (add-hook 'clojure-mode-hook #'my-clojure-mode-hook)

       (use-package cljr-helm
         :ensure t
         :init
         (bind-key "C-c r" 'cljr-helm clojure-mode-map)))

     (use-package clojure-mode-extra-font-locking
       :ensure t)
     )


   (use-package cider
     :pin melpa-stable
     :ensure t
     :init
     (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
     (setq cider-repl-result-prefix ";; => ")

     :config
     (bind-key ")" 'sp-up-sexp cider-repl-mode-map)

     (use-package ac-cider
       :ensure t
       :init
       (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
       (add-hook 'cider-mode-hook 'ac-cider-setup)
       (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
       (eval-after-load "auto-complete"
         '(progn
            (add-to-list 'ac-modes 'cider-mode)
            (add-to-list 'ac-modes 'cider-repl-mode)))))

   (use-package gist
     :ensure t
     :bind ("C-x g l" . gist-list))

   (use-package yagist
     :ensure t
     :bind ("C-x g c" . yagist-region-or-buffer))


   (use-package org
     :ensure t
     :bind ("C-x a" . org-agenda)
     :init
     (setq org-babel-clojure-backend 'cider)

     ;; Don't execute code blocks during export
     (setq org-export-babel-evaluate nil)
     :config
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (clojure . t)
        (dot . t)
        (sh . t)))

     ;; taken from https://github.com/howardabrams/dot-files/blob/master/elisp/ox-confluence.el
     (load-file  (expand-file-name "ox-confluence.el" user-emacs-directory)))

   (use-package sane-term
     :ensure t
     :bind (("C-x t" . sane-term)
            ("C-x T" . sane-term-create)))

   (use-package tramp-term
     :ensure t
     :bind ("C-x C-t" . tramp-term))

   (use-package graphviz-dot-mode
     :init
     (setq graphviz-dot-view-command "open -a Graphviz %s"))

   (use-package fish-mode
     :ensure t)
   #+END_SRC

* Footnotes

[fn:1] Found at http://www.emacswiki.org/emacs/TrampMode#toc31
