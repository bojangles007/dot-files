#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t h:4
#+PROPERTY: header-args:sh         :tangle yes
#+PROPERTY: header-args            :results silent
* Introduction

  This is my Emacs configuration. Because I'm prone to forget what does what,
  my configuration is in the form of a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose,
  interspaced with code.

  After many years with BBEdit I started looking at Emacs again when I started
  learning Clojure. I started with the "better defaults" package and added
  things one-by-one as I found them, rather than stealing someone else's
  mammoth =.emacs= file that I didn't understand any of. Initially I drew a
  lot of inspiration from [[https://github.com/magnars/.emacs.d][magnars' .emacs.d]], but after rewriting it using
  [[https://github.com/jwiegley/use-package][use-package]] (which is excellent) it is starting to feel like my own work.

  When I say this document uses literate programming, I mean that the
  configuration snippets here are not copied-and-pasted from my config, they
  /are/ my config. I use a tiny "bootloader", found in [[file:init.el][init.el]], that reads
  this file and parses out all the configuration snippets.

  However, this document doesn't just contain =emacs-lisp= snippets. It also
  contains some shell snippets to install Emacs itself, and some helper
  programs. By invoking =C-c C-v t= on this document a =README.sh= file is
  produced, that contains shell commands that will install all the helper
  programs via /brew/. (Yes, there's a small bootstrapping problem here. But
  recent Emacs distributions ships with the required Org mode support for
  most of this, so it's not really a problem.)

* Install Emacs & Setup =~/.emacs.d=

  I use [[http://brew.sh][homebrew]] to install Emacs. I use YAMAMOTO Mitsuharu's experimental
  "Mac port" addition to GNU Emacs 24. This provides much, /much/ nicer fonts.
  Also, it appears that this patched Emacs is a lot faster, particularly when
  invoking external processes. (Magit, specifically.) Finally, it seems to do
  the right thing when launching emerge from Magit, even in fullscreen.

  #+BEGIN_SRC sh
    brew tap caskroom/cask
    brew tap railwaycat/homebrew-emacsmacport
    brew cask install emacs-mac --with-spacemacs-icon
    mv /opt/homebrew-cask/Caskroom/emacs-mac/emacs-24.5-z-mac-5.15/Emacs.app/ /Applications/
  #+END_SRC

  I then create a symlink from =~/.emacs.d= to the directory containing this
  file. (Checking out this repo is the topic [[file:~/Dotfiles/README.org][covered here]].) If =~/.emacs.d= is
  already a symbolic link, this will delete it first. If it is a directory,
  move that out of the way.

  #+BEGIN_SRC sh
    test -L ~/.emacs.d && rm ~/.emacs.d
    test -d ~/.emacs.d && mv ~/.emacs.d ~/.emacs.d.$(date +%s)
    ln -s ~/Dotfiles/emacs.d ~/.emacs.d
  #+END_SRC

* Configure the base install

  Alright! Now on to the actual configuration. None of the stuff in this
  section requires external packages; it's all vanilla Emacs.

** Don't hide Emacs when  ⌘-h is pressed

   In Emacs Mac Port, ⌘-h bypasses any Emacs keybindings and instead sends a
   "pass command to system" message to Mac OSX, which then hides the entire
   application. [[https://github.com/railwaycat/homebrew-emacsmacport/issues/55][I don't want that]].

   #+BEGIN_SRC emacs-lisp
     (setq mac-pass-command-to-system nil)
   #+END_SRC

** Disable mouse interface, splash screen & beeps

   I don't tend to use a mouse in Emacs very often, so I turn off mouse
   interface early to avoid momentary display during launch.

   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
   #+END_SRC

   I also don't need to see a splash screen on every launch.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC

   I do not like Emacs to beep at me; I prefer a visual bell. Unfortunately
   in the current stable release there is a bug that causes [[http://debbugs.gnu.org/cgi/bugreport.cgi?bug%3D21662][visual artefacts]]
   on El Capitan. The workaround is to turn off visual bell, but make the
   function that actually rings the bell be a no-op. I'd like to get the
   visual bell back one day. It's been fixed upstream, but I've not been
   brave enough to build =--HEAD= yet, so so far I've stuck with the stable
   builds.

   #+BEGIN_SRC emacs-lisp
     (setq visible-bell nil)
     (setq ring-bell-function 'ignore)
   #+END_SRC

** Start in fullscreen

   I like fullscreen applications, so start Emacs in fullscreen.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'after-init-hook
                  (lambda ()
                    (set-frame-parameter nil 'fullscreen 'fullboth)))
   #+END_SRC

   Sometimes (when using ediff) I don't use fullscreen. By resizing the window
   by pixels rather than characters we can still fill the entire screen.

   #+BEGIN_SRC emacs-lisp
     (setq frame-resize-pixelwise t)
   #+END_SRC

** Disable kill-emacs

   Disable =s-q= (=kill-emacs=) as it is too close to =M-q= which I use for
   reflowing text.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-q") nil)
   #+END_SRC

** Put Custom settings in a separate file

   I prefer to code my configuration, but sometimes Custom settings are good
   enough. I prefer that such settings live in a separate file though. Load
   that file if it exists.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (if (file-exists-p custom-file)
         (load custom-file))
   #+END_SRC

** Internationalisation

   Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

   #+BEGIN_SRC emacs-lisp
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+END_SRC

   Let's define keybindings for the three additional Norwegian characters
   characters that I don't have natively on my British keyboard.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-'") (kbd "æ"))
     (global-set-key (kbd "s-\"") (kbd "Æ"))
     (global-set-key (kbd "s-O") (kbd "Ø"))
     (global-set-key (kbd "s-o") (kbd "ø"))
     (global-set-key (kbd "s-A") (kbd "Å"))
     (global-set-key (kbd "s-a") (kbd "å"))
     #+END_SRC

** Use Aspell with UK English Dictionary

   Configure Emacs to use the Queen's English for spell checking. Also, use
   /aspell/ rather than /ispell/.

   #+BEGIN_SRC emacs-lisp
     (setq ispell-program-name "aspell"
           ispell-dictionary "british")
   #+END_SRC

   Install aspell with the appropriate dictionary using brew.

   #+BEGIN_SRC sh
     brew install aspell
   #+END_SRC

** Extend word-wrap to 78 characters

   I prefer slightly wider fill-rate than the default of 70. Let's make it
   78, so we stay within 80 characters that so many people consider the holy
   grail.

   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 78)
   #+END_SRC

** Automatic word-wrap in text-mode

   Turn on automatic work-wrap in =text-mode=. Without this you end up with
   really long lines and have to manually insert linebreaks where you want
   them. (Or call e.g. =fill-paragraph=, bound to =M-q=, manually.)

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   #+END_SRC

** A sentence ends at a period

   Sentences do not need double spaces to end. Period.

   #+BEGIN_SRC emacs-lisp
     (set-default 'sentence-end-double-space nil)
   #+END_SRC

** Never insert tabs

   #+BEGIN_SRC emacs-lisp
   (set-default 'indent-tabs-mode nil)
   #+END_SRC

** End all files in a newline

   All files should end in a newline. Insert one if there isn't one already.

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Highlight & deal with whitespace annoyances

   This highlights certain whitespace annoyances, and adds a key binding to
   clean it up.

   #+BEGIN_SRC emacs-lisp
     (require 'whitespace)
     (setq whitespace-style '(face empty tabs trailing))
     (global-whitespace-mode t)

     (global-set-key (kbd "s-w") 'whitespace-cleanup)
   #+END_SRC

** Set up modifier keys on OS X

   Set up the modifier keys the way that best fits my keyboard.

   #+BEGIN_SRC emacs-lisp
     (setq mac-command-modifier 'meta
           mac-option-modifier 'super
           mac-control-modifier 'control
           ns-function-modifier 'hyper)
   #+END_SRC

** Auto revert mode

   When files change on disk, revert the buffer automatically.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

** Don't store backup files next to originals

   I don't like backup files (those dreaded =foo~= ones) all over my disk.
   This places them in =~/.emacs.d/backups=.

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
   #+END_SRC

** Transparently open compressed files

   I *do* like it when Emacs transparently opens compressed files. It gives
   me the warm fuzzies.

   #+BEGIN_SRC emacs-lisp
     (auto-compression-mode t)
   #+END_SRC

** Make 'y' and 'n' satisfy prompts

   Answering just 'y' or 'n' will do, rather than having to spell out "yes"
   or "no".

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** (Un-)comment line or region function

   I found this on StackOverflow, I think. If no region is selected it will
   toggle the current programming mode's comment for that line. If a region
   is selected it will comment/uncomment the region.

   #+BEGIN_SRC emacs-lisp
     (defun comment-or-uncomment-region-or-line ()
       "Comments or uncomments the region or the current line if there's no active region."
       (interactive)
       (let (beg end)
         (if (region-active-p)
             (setq beg (region-beginning) end (region-end))
           (setq beg (line-beginning-position) end (line-end-position)))
         (comment-or-uncomment-region beg end)
         (next-line)))

     (global-set-key (kbd "s-c") 'comment-or-uncomment-region-or-line)
   #+END_SRC

** Replace smart quotes function

   At some point I needed to remove some "smart quotes" from a blog post
   draft created in OS X Notes. I came up with this function. I don't
   remember needing to use it again, but I keep it for sentimental reasons.
   (It doesn't even have a keybinding!)

   #+BEGIN_SRC emacs-lisp
     (defun replace-smart-quotes (beg end)
       "Replace 'smart quotes' in buffer or region with ascii quotes."
       (interactive "r")
       (format-replace-strings '(("\x201C" . "\"")
                                 ("\x201D" . "\"")
                                 ("\x2018" . "'")
                                 ("\x2019" . "'"))
                               nil beg end))
   #+END_SRC

** Toggle Window Split function

   Sometimes a window is split horizontally, and you would prefer
   vertically. Or vice versa. This function can help! Just don't ask me how
   it works: I found it on StackOverflow. (I think. Again.)

   #+BEGIN_SRC emacs-lisp
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
                       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1))))))

     (define-key ctl-x-4-map "t" 'toggle-window-split)
   #+END_SRC

** Delete the file for the current buffer function

   "Delete this file." Simple, huh?

   #+BEGIN_SRC emacs-lisp
     (defun delete-current-buffer-file ()
       "Removes file connected to current buffer and kills buffer."
       (interactive)
       (let ((filename (buffer-file-name))
             (buffer (current-buffer))
             (name (buffer-name)))
         (if (not (and filename (file-exists-p filename)))
             (ido-kill-buffer)
           (when (yes-or-no-p "Are you sure you want to remove this file? ")
             (delete-file filename)
             (kill-buffer buffer)
             (message "File '%s' successfully removed" filename)))))

     (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
   #+END_SRC

** Eshell

   I have started using /Eshell/. It is close to magic. There's not a lot of
   setup (it has its own [[file:eshell/alias][alias file]]), but I've got a keybinding to bring up
   eshell quickly. This launches eshell if it is not already running, or
   switches to it if it is.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c s") 'eshell)
   #+END_SRC

   Eshell is great, and its Tramp integration allows me to open remote files
   in local Emacs seamlessly with the =find-file= command. (Which I have
   aliased to =ff=.) Eshell also makes sure that my shell behaves the same,
   and has the same config, whether I am on a local machine or a remote one.

** Tramp

   Allow using sudo over ssh, so we can sudo to root remotely on a machine
   that does not allow root login.

   #+BEGIN_SRC emacs-lisp
     (set-default 'tramp-default-proxies-alist
                  (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
   #+END_SRC

   For opening files using sudo locally, don't connect via SSH. (My local
   machine doesn't accept SSH connections.)

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'tramp-default-proxies-alist
                  '((regexp-quote (system-name)) nil nil))
   #+END_SRC

   If I don't set this then tramp will attempt to use OS X's tempfile
   directory on a remote machine, which does not work. I don't understand
   why it won't use the remote machine's temp directory automatically, but
   there you go.

   #+BEGIN_SRC emacs-lisp
     (setq temporary-file-directory "/tmp/")
   #+END_SRC

   Apparently using =ssh= is faster than the default =scp= mode, so let's use
   that.

   #+BEGIN_SRC emacs-lisp
   (setq tramp-default-method "ssh")
   #+END_SRC

   This function lets me re-open the currently open file using sudo[fn:1].
   I've bound it to =C-c C-s=. It works for both local and remote buffers.

   #+BEGIN_SRC emacs-lisp
     (defun sudo-edit-current-file ()
       (interactive)
       (let ((position (point)))
         (find-alternate-file
          (if (file-remote-p (buffer-file-name))
              (let ((vec (tramp-dissect-file-name (buffer-file-name))))
                (tramp-make-tramp-file-name
                 "sudo"
                 (tramp-file-name-user vec)
                 (tramp-file-name-host vec)
                 (tramp-file-name-localname vec)))
            (concat "/sudo:root@localhost:" (buffer-file-name))))
         (goto-char position)))
   #+END_SRC

   The man pages on my OS X local machine are very oqften different from the
   remote machines I'm logged in to. Thus, when in eshell, in a /remote/ path,
   I would like to display /remote/ man pages from that system. I'm not sure
   the regular man command can do that, but /woman/ can, with a bit of help.

   I've not /completely/ nailed this, so the useability is a bit rough. But
   with the below command in eshell you can do:

   #+BEGIN_EXAMPLE
   alias man 'tramp-aware-woman ${*man -c --path $1}'
   #+END_EXAMPLE

   Now you have an alias which will open a woman buffer with the /remote/ man
   page of the man page you want.

   #+BEGIN_SRC emacs-lisp
     (defun tramp-aware-woman (man-page-path)
       (interactive)
       (let ((dir (eshell/pwd)))
         (woman-find-file
          (if (file-remote-p dir)
              (let ((vec (tramp-dissect-file-name dir)))
                (tramp-make-tramp-file-name
                 (tramp-file-name-method vec)
                 (tramp-file-name-user vec)
                 (tramp-file-name-host vec)
                 man-page-path))
            man-page-path))))
   #+END_SRC

** Set up Clipboard

   These settings improve pasting behaviour with programs outside Emacs.

   Save clipboard strings into the kill ring before replacing them. This is
   useful if you select something in Emacs, then select something from
   _another_ program. If you don't set this to non-nil the previous selection
   done from within Emacs is gone. This preserves it in the kill ring,
   enabling you to retrieve it.

   #+BEGIN_SRC emacs-lisp
     (setq save-interprogram-paste-before-kill t)
   #+END_SRC

   Copying ("yanking") with the mouse copies at point, rather than where you
   click.

   #+BEGIN_SRC emacs-lisp
     (setq mouse-yank-at-point t)
   #+END_SRC

** Show more "recent files" in =M-x b= window

   Keep up to 100 recent files, rather than the default of 20.

   #+BEGIN_SRC emacs-lisp
    (setq recentf-max-saved-items 100)
   #+END_SRC

** Save my place in each file

   It's nice if Emacs knows where I was last time I opened a file.

   #+BEGIN_SRC emacs-lisp
     (setq-default save-place t)
     (setq save-place-file (concat user-emacs-directory "places"))
   #+END_SRC

** Save minibuffer history

   This allows us to "tap up" in the minibuffer to recall previous items,
   even from a previous session.

   #+BEGIN_SRC emacs-lisp
     (savehist-mode 1)
   #+END_SRC

** Show Matching parens

   This is extremely useful. Put the mark on a paren (any of =()[]{}=,
   actually) and Emacs shows the matching closing/opening one.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode 1)
   #+END_SRC

** Add keybinding to join next line to this

   With cursor at any point in a line, hit =M-j= to move to the end, and
   delete the newline. The cursor is left where the newline used to be.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-j")
                     (lambda ()
                       (interactive)
                       (join-line -1)))
   #+END_SRC

** Buffer-local regex search

   I like the =C-s= and =C-r= keybindings to mean "search forward/backward
   for this regex".

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-s") 'isearch-forward-regexp)
     (global-set-key (kbd "C-r") 'isearch-backward-regexp)
   #+END_SRC

** Enable Hippie expand

   From the documentation:

   #+BEGIN_QUOTE
   Try to expand text before point, using multiple methods.
   The expansion functions in `hippie-expand-try-functions-list' are
   tried in order, until a possible expansion is found.  Repeated
   application of `hippie-expand' inserts successively possible
   expansions.
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'hippie-expand)
   #+END_SRC

** Running tests

   Add a convenient keybinding for running tests interactively.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x t") 'ert)
   #+END_SRC

** IRC

   But /of course/ Emacs has a built-in IRC client. In fact it has two! But I
   digress. Let's use the oldest one, and configure it slightly.

   #+BEGIN_SRC emacs-lisp
   (setq rcirc-default-nick "stigbra")
   (setq rcirc-default-full-name "Stig Brautaset")
   #+END_SRC

** Composing & Sending Email

   Sending Email from Emacs? Yes please! First let Emacs know our preferred
   email client.

   #+BEGIN_SRC emacs-lisp
     (setq mail-user-agent 'gnus-user-agent)
     (setq read-mail-command 'gnus)
   #+END_SRC

   Discourage Rich Text messages.

   #+BEGIN_SRC emacs-lisp
   (setq mm-discouraged-alternatives
      '("text/richtext"))
   #+END_SRC

   I like to be able to read HTML email. Even in Gnus. Use the built-in
   renderer. This gives me the best of both worlds, IMO: immediate rendering
   of content, but open links clicked by mouse in external browser.

   #+BEGIN_SRC emacs-lisp
     (setq mm-text-html-renderer 'shr)
   #+END_SRC

   Use Org structure editing & table mode in Message mode. (Used for composing
   messages.) Also turn on yas minor mode, for form responses.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'message-mode-hook 'turn-on-orgstruct++)
     (add-hook 'message-mode-hook 'turn-on-orgtbl)
     (add-hook 'message-mode-hook 'yas-minor-mode)
   #+END_SRC

   Set up defaults for sending email.

   #+BEGIN_SRC emacs-lisp
     (setq send-mail-function 'smtpmail-send-it
           message-send-mail-function 'smtpmail-send-it
           starttls-extra-arguments nil
           smtpmail-smtp-service 587
           smtpmail-debug-info t)
   #+END_SRC

   List of sender addresses and SMTP servers.

   #+BEGIN_SRC emacs-lisp
     (setq smtp-accounts
           '(("stig@brautaset.org" "mailbox@brautaset.org" "mail.gandi.net")
             ("sbrautaset@laterpay.net" "sbrautaset@laterpay.ag" "smtp.gmail.com")))
   #+END_SRC

   A function to change the active SMTP server based on the sender address.
   (This is heavily inspired by [[http://www.mostlymaths.net/2010/12/emacs-30-day-challenge-using-gnus-to.html][emacs 30 day challenge: using gnus]].)

   #+BEGIN_SRC emacs-lisp
     (defun change-smtp (recipient smtpmail-text-buffer &rest ask-for-password)
       "Change the SMTP server & user according to current sender"

       (save-excursion
         (loop with from = (save-restriction
                             (message-narrow-to-headers)
                             (message-fetch-field "from"))
               for (address smtp-user smtp-server) in smtp-accounts
               when (string-match address from)
               do (progn
                    (message "Setting SMTP server to %s for user %s"
                             smtp-server smtp-user)
                    (setq smtpmail-smtp-user smtp-user
                          smtpmail-smtp-server smtp-server)))))
   #+END_SRC

   Add the `change-smtp' function as a "before advice" to the /real/ function
   to send mail via smpt. This causes `change-smtp' to be called immediately
   before the advised function, with the same arguments.

   #+BEGIN_SRC emacs-lisp
     (advice-add #'smtpmail-via-smtp
                 :before
                 #'change-smtp)
   #+END_SRC

   Add a function to cycle between from addresses in the message buffer.
   Credit to [[https://www.emacswiki.org/emacs/GnusTutorial][GnusTutorial]] which is where I found the example I adopted this
   from.

   #+BEGIN_SRC emacs-lisp
     (setq my-email-addresses (mapcar (lambda (lst) (car lst) ) smtp-accounts))
     (setq message-alternative-emails
           (regexp-opt my-email-addresses))

     (setq message-from-selected-index 0)
     (defun message-loop-from ()
       (interactive)
       (setq message-article-current-point (point))
       (goto-char (point-min))
       (if (eq message-from-selected-index (length my-email-addresses))
           (setq message-from-selected-index 0) nil)
       (while (re-search-forward "^From:.*$" nil t)
         (replace-match (concat "From: " user-full-name " <" (nth message-from-selected-index my-email-addresses) ">")))
       (goto-char message-article-current-point)
       (setq message-from-selected-index (+ message-from-selected-index 1)))

     (add-hook 'message-mode-hook
               (lambda ()
                 (define-key message-mode-map "\C-c\C-f\C-f" 'message-loop-from)))
   #+END_SRC

* ELPA packages
** Leuven Theme

   Install & activate a nice-looking theme.

   #+BEGIN_SRC emacs-lisp
     (use-package leuven-theme
       :ensure t
       :config
       (load-theme 'leuven t))
   #+END_SRC

** Magit

   I use [[http://magit.vc][Magit]] all day. If you use git a lot it's possibly worth switching to
   Emacs just for it. It is excellent. I bind =M-m= to =magit-status=, which
   is the main entry point for the mode.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t

       :bind ("M-m" . magit-status)

       :init
       (setq magit-git-executable "/usr/bin/git"
             git-commit-summary-max-length 78
             magit-diff-refine-hunk 'all
             magit-push-always-verify nil))
   #+END_SRC

   I also use a Magit plugin that interacts with GitHub, allowing me to create
   pull-requests from within Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package magit-gh-pulls
       :ensure t
       :config
       (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))
   #+END_SRC

** SmartParens

   I use smartparens rather that paredit. I cannot remember why; probably
   something to do with it being better supported for Cider/Clojure? Anyway,
   here's my SmartParen config. It is  mostly cribbed from the author, with
   small changes to make suitable for plugging into =user-package=.

   One notable thing: I remove "'" from being a pair, because that character
   is used for quoting in lisps, and for apostrophe in text modes. Having two
   inserted every time you hit the key is very annoying.

   #+BEGIN_SRC emacs-lisp
   (use-package smartparens
     :ensure t

     :config
     (smartparens-global-mode t)
     (show-smartparens-global-mode t)
     (sp-pair "'" nil :actions :rem)

     ;; Add smartparens-strict-mode to all sp--lisp-modes hooks. C-h v sp--lisp-modes
     ;; to customize/view this list.
     (mapc (lambda (mode)
             (add-hook (intern (format "%s-hook" (symbol-name mode))) 'smartparens-strict-mode))
           sp--lisp-modes)

     ;; Conveniently set keys into the sp-keymap, limiting the keybinding to buffers
     ;; with SP mode activated
     (mapc (lambda (info)
             (let ((key (kbd (car info)))
                   (function (car (cdr info))))
               (define-key sp-keymap key function)))
           '(("C-M-f" sp-forward-sexp)
             ("C-M-b" sp-backward-sexp)

             ("C-M-d" sp-down-sexp)
             ("C-M-a" sp-backward-down-sexp)
             ("C-S-a" sp-beginning-of-sexp)
             ("C-S-d" sp-end-of-sexp)

             ("C-M-e" sp-up-sexp)

             ("C-M-u" sp-backward-up-sexp)
             ("C-M-t" sp-transpose-sexp)

             ("C-M-n" sp-next-sexp)
             ("C-M-p" sp-previous-sexp)

             ("C-M-k" sp-kill-sexp)
             ("C-M-w" sp-copy-sexp)

             ("C-M-<delete>" sp-unwrap-sexp)
             ("C-M-<backspace>" sp-backward-unwrap-sexp)

             ("C-<right>" sp-forward-slurp-sexp)
             ("C-<left>" sp-forward-barf-sexp)
             ("C-M-<left>" sp-backward-slurp-sexp)
             ("C-M-<right>" sp-backward-barf-sexp)

             ("M-D" sp-splice-sexp)
             ("C-M-<delete>" sp-splice-sexp-killing-forward)
             ("C-M-<backspace>" sp-splice-sexp-killing-backward)
             ("C-S-<backspace>" sp-splice-sexp-killing-around)

             ("C-]" sp-select-next-thing-exchange)
             ("C-<left_bracket>" sp-select-previous-thing)
             ("C-M-]" sp-select-next-thing)

             ("M-F" sp-forward-symbol)
             ("M-B" sp-backward-symbol)

             ("H-t" sp-prefix-tag-object)
             ("H-p" sp-prefix-pair-object)
             ("H-s c" sp-convolute-sexp)
             ("H-s a" sp-absorb-sexp)
             ("H-s e" sp-emit-sexp)
             ("H-s p" sp-add-to-previous-sexp)
             ("H-s n" sp-add-to-next-sexp)
             ("H-s j" sp-join-sexp)
             ("H-s s" sp-split-sexp)))

     ;; In Lisp modes, let ')' go to end of sexp
     (bind-key ")" 'sp-up-sexp emacs-lisp-mode-map)
     (bind-key ")" 'sp-up-sexp lisp-mode-map))
   #+END_SRC

** Aggressive Indent

   I like to keep my code indented properly at all times. Aggressive-indent
   helps ensure this. Turn it on for lisp modes.

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :ensure t

       :config
       (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
       ;;     (add-hook 'puppet-mode-hook #'aggressive-indent-mode)
       (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
       (add-hook 'css-mode-hook #'aggressive-indent-mode))
   #+END_SRC

** Helm

   I use [[https://github.com/emacs-helm/helm][Helm]] for interactive completion and finding things, particularly files.

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t

       :bind (("C-c C-h e" . helm-list-elisp-packages)
              ("C-c C-h r" . helm-resume)
              ("M-x" . helm-M-x)
              ("M-y" . helm-show-kill-ring)
              ("C-x b" . helm-mini)
              ("C-x 4 b" . helm-mini)
              ("C-x C-f" . helm-find-files)))
   #+END_SRC

** Autocomplete

   I use auto-complete. I am not entirely sure to what extent, but this is my
   config for it.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-complete
       :ensure t
       :config
       (ac-config-default)
       (global-auto-complete-mode))
   #+END_SRC

** Editorconfig

   Some projects I touch, particularly at work, use [[http://editorconfig.org][editorconfig]] to set up
   their indentation and file format preferences.

   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :ensure t)
   #+END_SRC

   Emacs requires an external tool for this to work. I install that using
   brew.

   #+BEGIN_SRC sh
     brew install editorconfig
   #+END_SRC

** Puppet

   My work includes editing a lot of puppet manifests. Puppet-mode makes that
   more convenient.

   #+BEGIN_SRC emacs-lisp
     (use-package puppet-mode
       :mode "\\.pp'")
   #+END_SRC

** Ag / The Silver Searcher

   I use =ag= for searching quite a lot in Emacs.
   This requires an additional external tool for best performance:

   #+BEGIN_SRC sh
     brew install the_silver_searcher
   #+END_SRC

   Then make sure the Emacs ag package is installed.

   #+BEGIN_SRC emacs-lisp
     (use-package ag :ensure t)
   #+END_SRC

   The =helm-ag= package allows me to refine ag results (in case there are
   very many) using Helm's interactive narrowing down.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-ag :ensure t)
   #+END_SRC

   "Writable grep" mode for ag is pretty close to magic. When in a buffer
   showing ag results, try hitting =C-c C-p=--this lets you _edit the results
   of the search, right from the ag results buffer!_ Just hit =C-x C-s= to
   save the results.

   If you hit =C-c C-p= while already in writable grep mode you can delete the
   entire matched line from the file where it was found by hitting =C-c C-d=
   on it. I use this _a lot_ when cleaning up Hieradata.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep-ag :ensure t)
   #+END_SRC

** Projectile

   I use Projectile to navigate my projects. Some of the things I like about
   it are that it provides the following key bindings:

   - =C-c p t= :: This switches from an implementation file to its test file,
                  or vice versa. I use this extensively in Clojure mode. It
                  might not make sense for all languages; YMMV.
   - =C-c p 4 t= :: The same, as above, but open the file in "other" buffer.
   - =C-c p s s= :: Ag search for something in this project. If point is at a
                    token, default to searching for that. (Mnemonic:
                    "Projectile Silver Searcher".)

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (projectile-global-mode))
   #+END_SRC

   This next package adds =C-c p h=, which invokes =helm-find-file= in project
   context. Invaluable.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :ensure t)
   #+END_SRC

** Flycheck

   Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs,
   intended as replacement for the older Flymake extension which is part of
   GNU Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
     :ensure t)
   #+END_SRC

*** On-the-fly spell checking for email/ news messages

    Do spell checking on-the-fly in message mode.

    #+BEGIN_SRC emacs-lisp
      (use-package flyspell-lazy
        :ensure t
        :config
        (defun my-message-setup-routine ()
          (flyspell-mode 1))
        (add-hook 'message-mode-hook 'my-message-setup-routine))
    #+END_SRC

** Multiple Cursors

   This package is another one of those near-magical ones. It allows me to do
   multiple edits in the same buffer, using several cursors. You can think of
   it as an interactive macro, where you can constantly see what's being done.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t

       :bind (("C-c M-e" . mc/edit-lines)
              ("C-c M-a" . mc/mark-all-dwim)
              ("s-n" . mc/mark-next-like-this)
              ("s-p" . mc/mark-previous-like-this)))
   #+END_SRC

** Clojure Programming Support

   I use [[https://github.com/clojure-emacs/clojure-mode/][Clojure Mode]] for my Clojure editing.

   Note that this code block is not closed! We close it at the end of the
   section, so that all the remaining blocks are encapsulated in it. That
   means they will only be installed if clojure-mode is installed.

   I like that because these update almost every day, but I don't use them at
   work so it's annoying to have to update them so frequently there.

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :mode "\\.clj\\'"

       :config
       (bind-key ")" 'sp-up-sexp clojure-mode-map)
   #+END_SRC

   I have a package for extra syntax highlighting in Clojure mode, but I'm not
   sure how much it actually does.

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode-extra-font-locking
       :ensure t)
   #+END_SRC

   YAS is a templating package. You can define mode-specific or global
   templates, and insert templates with keycombinations or triggered based on
   trigger words in the text. I used to have this globally active, but it
   interferes with some of org mode that I want, so now only activate it in
   Clojure Mode, where it is required for refactoring support.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :config
       (yas-minor-mode 1))
   #+END_SRC

   The Clojure Refactor package is also ace.

   #+BEGIN_SRC emacs-lisp
     (use-package clj-refactor
       :ensure t
       :config
       (dolist (mapping '(("route" . "compojure.route")
                          ("timbre" . "taoensso.timbre")
                          ("component" . "com.stuartsierra.component")
                          ("d" . "datomic.api")
                          ("io" . "clojure.java.io")
                          ("tc" . "clojure.test.check")
                          ("gen" . "clojure.test.check.generators")
                          ("prop" . "clojure.test.check.properties")
                          ("prop'" . "com.gfredericks.test.chuck.properties")))
         (add-to-list 'cljr-magic-require-namespaces mapping t))

       :config
       (defun my-clojure-mode-hook ()
         (clj-refactor-mode 1))

       (add-hook 'clojure-mode-hook #'my-clojure-mode-hook))
   #+END_SRC

   The cljr-helm package allows us to interactively narrow down the (ever
   growing) list of clj-refactoring choices using helm.

   #+BEGIN_SRC emacs-lisp
     (use-package cljr-helm
       :ensure t
       :init
       (bind-key "C-c r" 'cljr-helm clojure-mode-map))
   #+END_SRC

   For REPL work I use [[https://github.com/clojure-emacs/cider][CIDER]].

   #+BEGIN_SRC emacs-lisp
     (use-package cider
       :ensure t
       :init
       (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
       (setq cider-repl-result-prefix ";; => ")

       :config
       (bind-key ")" 'sp-up-sexp cider-repl-mode-map))
   #+END_SRC

   CIDER requires the Leiningen external tool. It is installed with brew, of
   course.

   #+BEGIN_SRC sh
     brew install leiningen
   #+END_SRC

   BTW, I like auto-complete to work in CIDER too:

   #+BEGIN_SRC emacs-lisp
     (use-package ac-cider
       :ensure t
       :init
       (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
       (add-hook 'cider-mode-hook 'ac-cider-setup)
       (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
       (eval-after-load "auto-complete"
         '(progn
            (add-to-list 'ac-modes 'cider-mode)
            (add-to-list 'ac-modes 'cider-repl-mode))))
   #+END_SRC

   Now we have to close the =clojure-mode= block:

   #+BEGIN_SRC emacs-lisp
   )
   #+END_SRC

** Gists

   Viewing & editing gists in Emacs? Sure! I want that!

   #+BEGIN_SRC emacs-lisp
     (use-package gist
       :ensure t
       :bind ("C-x g l" . gist-list))
   #+END_SRC

   Yagist, a fork of the above package, has the edge when it comes to actually
   _create_ gists.

   #+BEGIN_SRC emacs-lisp
     (use-package yagist
       :ensure t
       :bind ("C-x g c" . yagist-region-or-buffer-private))
   #+END_SRC

** Org

   I used to use Markdown for my writing, but now I tend to use Org mode. The
   Emacs org mode's support for tables, TOC, footnotes, TODO and agenda items
   makes it an easy choice. (I can even export to Markdown if I want.)

   First we need to make sure the =org-plus-contrib= package is installed, as
   we use some contributions from there.

   #+BEGIN_SRC emacs-lisp
     (use-package org-plus-contrib
       :ensure t)
   #+END_SRC

   Anoyingly, we cannot use that same block for the config, because the module
   is still called just =org=. So we have a separate block for that.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       ;; The Org manual expects these to be available in any mode, so set them here.
       :bind (("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c c" . org-capture)
              ("C-c b" . org-iswitchb)
              :map org-mode-map
              ("C-n" . org-next-link)
              ("C-p" . org-previous-link))
       :init
       (setq org-babel-clojure-backend 'cider)

       ;; Log a timestamp & a note whenever an entry is completed
       (setq org-log-done 'note)

       ;; Sometimes I accidentally edit non-visible parts of org document. This
       ;; helps, apparently.
       (setq org-catch-invisible-edits t)

       ;; Don't execute code blocks during export
       (setq org-export-babel-evaluate nil)

       ;; Tell Org where to find ditaa jar
       (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")

       ;; Always include stderr output for shell
       (setq org-babel-default-header-args:sh
             '((:prologue . "exec 2>&1")
               (:epilogue . ":")))

       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (clojure . t)
          (ditaa . t)
          (dot . t)
          (sql . t)
          (sh . t))))
   #+END_SRC

   Ditaa has to be installed manually. It's a cool toy, so let's do that.

   #+BEGIN_SRC sh
     brew install ditaa
   #+END_SRC

   I hate writing JIRA markup, so I wrote a JIRA export backend for Org mode.
   It should be available on Melpa now.

   #+BEGIN_SRC emacs-lisp
     (use-package ox-jira)
   #+END_SRC

   I'm not that fond of writing Markdown anymore either:

   #+BEGIN_SRC emacs-lisp
     (use-package ox-gfm)
     (use-package ox-md)
   #+END_SRC

   Not only that, but I want to be able to create MIME HTML mail based on
   org-formatted source. There's a package for that too, of course.

   #+BEGIN_SRC emacs-lisp
     (require 'org-mime)
     (add-hook 'message-mode-hook
               (lambda ()
                 (local-set-key "\C-c\C-h" 'org-mime-htmlize)))
   #+END_SRC

** Org passwords

   #+BEGIN_SRC emacs-lisp
     (use-package org-passwords
       :init

       ;; Where's my passwords file?
       (setq org-passwords-file "~/Org/passwords.org.gpg")

       ;; Use completion for org elements
       (setq org-completion-use-ido t)

       :bind (("C-c P P" . org-passwords)
              ("C-c P g" . org-passwords-generate-password)
              :map org-passwords-mode-map
              ("C-c C-c u" . org-passwords-copy-username)
              ("C-c C-c p" . org-passwords-copy-password)))
   #+END_SRC

** Sphinx & reStructuredText

   I like to build Sphinx docs locally to check I've got the right syntax, and
   that links are accounted for. I use sphinx-fronted for that:

   #+BEGIN_SRC emacs-lisp
   (use-package sphinx-frontend)
   #+END_SRC

   That does require installing python, as OS X's default install doesn't come
   with pip:

   #+BEGIN_SRC sh
     brew install python
   #+END_SRC

   Then, we need to install sphinx itself:

   #+BEGIN_SRC sh
     pip install sphinx
   #+END_SRC

   I like to export initial draft in Org mode to ReST:

   #+BEGIN_SRC emacs-lisp
   (use-package ox-rst)
   #+END_SRC

   While we're at it, turn on auto-complete for reStructuredText.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-complete-rst
       :mode "\\.rst\'"
       :config
       (auto-complete-rst-init)
       (setq auto-complete-rst-other-sources
             '(ac-source-filename
               ac-source-abbrev
               ac-source-dictionary
               ac-source-yasnippet)))
   #+END_SRC

** Graphviz

   I sometimes use Graphviz to create diagrams. I have to actually install the
   graphviz program separately using brew.

   #+BEGIN_SRC sh
   brew install graphviz --with-app
   #+END_SRC

   I also have to tell Emacs how to launch GraphViz.

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :init
       (setq graphviz-dot-view-command "open -a Graphviz %s"))
   #+END_SRC

** Fish

   Add a mode for editing [[http://fishshell.com][FISH]] shell files.

   #+BEGIN_SRC emacs-lisp
     (use-package fish-mode :ensure t)
   #+END_SRC

** Trash

   This allows moving files to trash rather than deleting them from =dired=.
   Delete files by moving them to Trash. This way they _can_ be retrieved
   again.

   #+BEGIN_SRC emacs-lisp
     (use-package osx-trash
       :ensure t
       :init
       (setq delete-by-moving-to-trash t)
       :config
       (osx-trash-setup))
   #+END_SRC

   To support that we need to install a supporting program.

   #+BEGIN_SRC sh
    brew install trash
   #+END_SRC

** Plant UML Mode

   I use this for [[http://plantuml.com/sequence.html][sequence diagrams]] etc.

   #+BEGIN_SRC emacs-lisp
     (use-package puml-mode
       :mode "\\.puml\\'"
       :init
       (setq puml-plantuml-jar-path "/usr/local/Cellar/plantuml/8031/plantuml.8031.jar"))
   #+END_SRC

   This requires installing plantuml using brew.

   #+BEGIN_SRC sh
     brew install plantuml
   #+END_SRC

** Email support

   Use /message-x/ for some nice auto-completion in headers, and body.

   #+BEGIN_SRC emacs-lisp
     (use-package message-x :ensure t)
   #+END_SRC

   Also, use bbdb to manage contacts. I don't have a good two-way synch
   between iCloud contacts and BBDB, but selecting all contacts in
   Contacts.app and exporting them as a vCard archive can be imported with
   =bbdb-vcard-import-file=.

   #+BEGIN_SRC emacs-lisp
     (use-package bbdb :ensure t)
     (use-package bbdb-vcard :ensure t)
   #+END_SRC

   Load the offlineimap package before Gnus starts.

   #+BEGIN_SRC emacs-lisp
     (use-package offlineimap
       :ensure t
       :config
       (add-hook 'gnus-before-startup-hook 'offlineimap))
   #+END_SRC

   Supply passwords to offlineimap

   #+BEGIN_SRC emacs-lisp
     (defun offlineimap-get-password (host port)
          (let* ((netrc (netrc-parse (expand-file-name "~/.authinfo.gpg")))
                 (hostentry (netrc-machine netrc host port port)))
            (when hostentry (netrc-get hostentry "password"))))
   #+END_SRC

   This requires the Emacs server to be running.

   #+BEGIN_SRC emacs-lisp
     (unless (server-running-p)
       (server-start))
   #+END_SRC

* Footnotes

[fn:1] Found at http://www.emacswiki.org/emacs/TrampMode#toc31
